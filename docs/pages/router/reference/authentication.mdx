---
title: Authentication in Expo Router
sidebar_title: Authentication
description: How to protect routes with Expo Router.
hideTOC: true
---

import { FileTree } from '~/ui/components/FileTree';
import { YesIcon, NoIcon } from '~/ui/components/DocIcons';
import { Lock01Icon, LockUnlocked01Icon, ArrowsTriangleSolidIcon } from '@expo/styleguide-icons';
import { Collapsible } from '~/ui/components/Collapsible';

In Expo Router, all routes are always defined and accessible. You can use runtime logic to redirect users and block access to certain screens based on **authorization**.

There are a couple different techniques for protecting routes, we'll cover a basic example that favors how standard native apps work.

It's common to restrict certain routes to users who are not authenticated. This can be achieved in a very organized way by using React Context and Route Groups.

Consider the following project structure:

<FileTree
  files={[
    'app/_layout.js',
    [
      'app/(app)/_layout.js',
      <span>
        Protects child routes <ArrowsTriangleSolidIcon className="inline mb-1" />
      </span>,
    ],
    [
      'app/(app)/index.js',
      <span>
        Requires authorization <Lock01Icon className="inline mb-1" />
      </span>,
    ],
    [
      'app/(auth)/sign-in.js',
      <span>
        Always accessible <LockUnlocked01Icon className="inline mb-1" />
      </span>,
    ],
  ]}
/>

First, we'll setup a [React Context provider](https://react.dev/reference/react/createContext) that we can use to expose an authentication session to the entire app. This provider will use a mock implementation, you can replace it with your own [authentication provider](/guides/authentication/).

```js ctx.tsx
import React from 'react';
import { useStorageState } from './useStorageState';

const AuthContext = React.createContext(null);

// This hook can be used to access the user info.
export function useSession() {
  const value = React.useContext(AuthContext);
  if (!value && process.env.NODE_ENV !== 'production') {
    throw new Error('`useSession` must be wrapped in a <SessionProvider />');
  }

  return value;
}

export function SessionProvider(props) {
  const [[isLoading, session], setSession] = useStorageState('session');

  return (
    <AuthContext.Provider
      value={{
        signIn: () => {
          setSession('xxx');
        },
        signOut: () => {
          setSession(null);
        },
        user: session,
        isLoading,
      }}>
      {props.children}
    </AuthContext.Provider>
  );
}
```

<Collapsible summary="Persistent storage hook">

```ts useStorageState.ts
import * as SecureStore from 'expo-secure-store';
import * as React from 'react';
import { Platform } from 'react-native';

type UseStateHook<T> = [[boolean, T | null], (value?: T | null) => void];

function useAsyncState<T>(initialValue?: [boolean, T | null]): UseStateHook<T> {
  return React.useReducer(
    (state: [boolean, T | null], action?: T | null) => [
      false,
      action === undefined ? null : action,
    ],
    initialValue ?? [true, undefined]
  ) as UseStateHook<T>;
}

export async function setStorageItemAsync(key: string, value: string | null) {
  if (Platform.OS === 'web') {
    if (value == null) {
      localStorage.removeItem(key);
    } else {
      localStorage.setItem(key, value);
    }
  } else {
    if (value == null) {
      await SecureStore.deleteItemAsync(key);
    } else {
      await SecureStore.setItemAsync(key, value);
    }
  }
}

export function useStorageState(key: string): UseStateHook<string> {
  // Public
  const [state, setState] = useAsyncState<string>();

  // Get
  React.useEffect(() => {
    if (Platform.OS === 'web') {
      if (typeof localStorage !== 'undefined') {
        setState(localStorage.getItem(key));
      }
    } else {
      SecureStore.getItemAsync(key).then(value => {
        setState(value);
      });
    }
  }, [key]);

  // Set
  const setValue = React.useCallback(
    (value: string | null) => {
      setStorageItemAsync(key, value).then(() => {
        setState(value);
      });
    },
    [key]
  );

  return [state, setValue];
}
```

</Collapsible>

Now we can use this `SessionProvider` in the root layout to provide the authentication context to the entire app. It's imperative that the `<Slot />` is mounted before any navigation events are triggered, otherwise a runtime error will be thrown.

```jsx app/_layout.js
import { Slot } from 'expo-router';
import { SessionProvider } from '../ctx';

export default function Root() {
  return (
    // Setup the auth context and render our layout inside of it.
    <SessionProvider>
      <Slot />
    </SessionProvider>
  );
}
```

Next, we'll create a layout route which will be used to protect all of the child routes. This layout will be used to redirect users to the sign in screen if they are not authenticated.

```jsx app/(app)/_layout.js
import { Link, Redirect, Stack } from 'expo-router';
import { Text, View } from 'react-native';

import { useSession } from '../../ctx';

export default function AppLayout() {
  const { user, isLoading } = useSession();

  // You can keep the splash screen open, or render a loading screen.
  if (isLoading) {
    return <Text>Loading...</Text>;
  }

  // Only do authorization on the (app) group as users should always be able to access the (auth) group and sign-in again.
  if (!user) {
    // On web, static rendering will stop here as the user is not authenticated in the headless Node process that the pages are rendered in.
    return <Redirect href="/sign-in" />;
  }

  // This layout can be deferred because it's not the root layout.
  return <Stack />;
}
```

Now we can create our `/sign-in` page, which can toggle the authentication using `signIn()`. Because this screen is outside of the `(app)` group, it won't be protected by the layout.

```jsx app/sign-in.js
import { router } from 'expo-router';
import { Text, View } from 'react-native';

import { useSession } from '../ctx';

export default function SignIn() {
  const { signIn } = useSession();
  return (
    <View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}>
      <Text
        onPress={() => {
          signIn();
          // Navigate after signing in. You may want to tweak this to ensure sign-in is
          // successful before navigating.
          router.replace('/');
        }}>
        Sign In
      </Text>
    </View>
  );
}
```

And finally we'll implement an authenticated screen which can sign out.

```jsx app/(app)/index.js
import { Text, View } from 'react-native';

import { useSession } from '../../ctx';

export default function Index() {
  const { signOut } = useSession();
  return (
    <View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}>
      <Text
        onPress={() => {
          // The `app/(app)/_layout.tsx` will redirect to the sign-in screen.
          signOut();
        }}>
        Sign Out
      </Text>
    </View>
  );
}
```

Now if the authentication state changes globally, the user will be redirected to the appropriate route.

## Alternative loading states

In Expo Router, something must be rendered to the screen during the loading of the initial auth state. In the example above, we render a loading state in the app layout. Alternatively, you can make the `index` route a loading state, and move the initial route to something like `/home`, this is akin to how Twitter works.

## Troubleshooting

### Navigating without navigation

If you encounter the following error:

```
Error: Attempted to navigate before mounting the Root Layout component. Ensure the Root Layout component is rendering a Slot, or other navigator on the first render.
```

This can occur when you fail to mount a navigator in the root layout, and then attempt to navigate to a route. You can fix this by adding a group and moving conditional logic up a level.

```js app/_layout.js
export default function RootLayout() {
  React.useEffect(() => {
    // This navigation event will trigger the error above.
    router.push('/foobar');
  }, []);

  // Avoid deferring the root layout, otherwise the navigation event will be triggered before the layout is mounted.
  if (isLoading) {
    return <Text>Loading...</Text>;
  }

  return <Slot />;
}
```

## Caveats

Expo Router on web currently only supports build-time static generation and has no support for server-side rendering or custom middleware. This can be added in the future to provide a more optimal web experience.
